// Effpi - verified message-passing programs in Dotty
// Copyright 2019 Alceste Scalas and Elias Benussi
// Released under the MIT License: https://opensource.org/licenses/MIT
package effpi.verifier.mcrl2

/** A map-like class generating fresh values for keys of type A.
  * 
  * The first time an unknown key is accessed, a fresh identifier is
  * created (of type {@code String}, using the given {@code prefix}
  * and {@code suffix}); the identifier is remembered, and returned
  * for future calls.
  * 
  * @param init initial contents for the map-like store
  */
protected[mcrl2] class FreshNames[A](val description: String,
                                     prefix: String, suffix: String,
                                     init: Map[A, String], base: Int,
                                     renderer: A => String) {
  // NOTE: the following map preserves insertion order when iterating
  val store = scala.collection.mutable.LinkedHashMap[A, String](init.toSeq:_*)
  var nextFreshId: Int = base // Used to remember the next available id

  /** Return an unique identifier for @x, remembering it for future calls */
  def apply(x:A): String = synchronized {
    if (store.contains(x)) store(x)
    else {
      val freshId = nextFreshId
      nextFreshId += 1
      val ret = s"${prefix}${freshId}${suffix}"
      store += (x -> ret)
      ret
    }
  }

  /** Return a legend of all autogenerated identifiers, skipping @init */
  def legend: String = synchronized {
    val exclude = init.keySet
    val ret = store.view.filterKeys(k => !exclude.contains(k)).map { kv =>
      s"% ${kv._1} => ${kv._2}\n"
    }.foldLeft("")(_ ++ _)
    if (ret.isEmpty) "% (none)\n" else ret
  }

  /** Filter the store entries, returning a read-only map. */
  def filter(f: ((A, String)) => Boolean): Map[A, String] = {
    store.filter(f).toMap
  }
  
  /** Map the name store into a read-only map. */
  def map[B, C](f: ((A, String)) => (B, C)): Map[B, C] = {
    store.map(f).toMap
  }
}

object FreshNames {
  def apply[A](description: String,
               prefix: String, suffix: String,
               renderer: A => String): FreshNames[A] = {
    new FreshNames(description, prefix, suffix, Map.empty, 0, renderer)
  }

  def apply[A](description: String,
               prefix: String, suffix: String): FreshNames[A] = {
    new FreshNames(description, prefix, suffix, Map.empty, 0, _.toString)
  }

  def apply[A](description: String,
               prefix: String, suffix: String,
               init: Map[A, String], base: Int): FreshNames[A] = {
    new FreshNames(description, prefix, suffix, init, base, _.toString)
  }

  def apply[A](description: String,
               prefix: String, suffix: String,
               init: Map[A, String], base: Int,
               renderer: A => String): FreshNames[A] = {
    new FreshNames(description, prefix, suffix, init, base, renderer)
  }
}
