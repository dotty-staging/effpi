// Effpi - verified message-passing programs in Dotty
// Copyright 2019 Alceste Scalas and Elias Benussi
// Released under the MIT License: https://opensource.org/licenses/MIT
package effpi.verifier.mcrl2

import effpi.verifier.{ValueType, GroundType, AppType, TypeVar, SyntTypeVar, TypeVarPrefix, Mailbox}
import effpi.verifier.ccst
import effpi.verifier.util.resource

import dotty.tools.dotc.core.Contexts.Context
import dotty.tools.dotc.report

/** Representation of an mCRL2 process */
protected[verifier] sealed abstract class Spec(ccstTerm: ccst.CCST, val description: String = "") {
  val filename: String = "spec"

  /** Return all approximate uses of the given type variable `v`
   *  (i.e., all types occurring as either input or output subjects, that
   *  are supertypes of `v`.
   */
   // TODO: ideally, we should not have `ctx` in this class...
   def approxUses(v: TypeVar)(implicit ctx: Context): Set[String] = {
     ccstTerm.approxUses(v).map { lookup(_) }
   }

  /** Return all approximate uses of the given type variable `v`
   *  (i.e., all types occurring as either input or output subjects, that
   *  are supertypes of `v`.
   */
  // TODO: ideally, we should not have `ctx` in this class...
  def approxUses(v: String)(implicit ctx: Context): Set[String] = {
    // Retrieve the variable from the store
    val tvs = variables.store.keySet.filter {
      case TypeVar(name, _) => name.toString == v
      case _other => false
    }.toSeq
    assert(tvs.size <= 1)
    if (tvs.size == 0) Set()
    else {
      // NOTE: the following cast is ugly but safe: above, we only pick TypeVars
      ccstTerm.approxUses(tvs(0).asInstanceOf[TypeVar]).map { lookup(_) }
    }
  }

  /** Generate a legend for the autogenerated mCRL2 specification */
  private def legend: String = {
    // Iterate on all name suppliers defined below
    val nameSuppliers = Seq(
      variables, mailboxes, channelTypes, groundTypes, processes
    )

    val transforms: String = {
      s"%%% Original type: TODO\n\n" ++ // FIXME
      s"%%% CCST spec: ${ccstTerm}\n\n" // FIXME
    }

    transforms ++ nameSuppliers.map { ns =>
      s"%%% ${ns.description}\n" ++ ns.legend ++ "\n"
    }.foldLeft(""){ _ ++ _ }
  }

  // Name suppliers for the mCRL2 spec encoding
  private val variables = FreshNames("Variables",
                                     "v(", ")", Map[SyntTypeVar|TypeVar|TypeVarPrefix, String](
    // Insert here a mapping to define commonly-used variables
    // NOTE: must be kept in sync with resources/mpst-preamble.mcrl2
  ), 1000) // The base must be large enough to skip indexes for entries above
  
  private val mailboxes = FreshNames[Mailbox]("Mailboxes",
                                              "mb(", ")")
  
  private val channelTypes = FreshNames[ValueType]("Channel types",
                                        "ct(", ")")

  private val groundTypes = FreshNames[ValueType]("Ground types",
                                       "gt(", ")", Map[ValueType, String](
    // Insert here a mapping to define commonly-used ground types
    // NOTE: must be kept in sync with resources/mpst-preamble.mcrl2
  ), 10) // The base must be large enough to skip the entries above

  /** Lookup or generate the name of the given ValueType */
  private def lookup(t: ValueType): String = t match {
    case v: TypeVar => s"tvar(${variables(v)})"
    case v: SyntTypeVar => s"tvar(${variables(v)})"
    case vp: TypeVarPrefix => vp.prefix match {
      // FIXME: temporary simplification
      // We collapse a path-dependent types: e.g., x.replyTo.type => x.type
      // This means that we may confuse the usages of two distinct fields
      // x.a.type and x.b.type, if they have a same channel supertype.
      // Solution: preserve path-dependent types, and handle them properly
      //           when generating .mcf formulas from their templates
      case tv: TypeVar => s"tvar(${variables(tv)})"
      // NOTE: the following is an artifact obtained when generating coarse
      // input branches in CCST input processes.  Take In[c, (x:T) => Cont]:
      // we obtain an input branch where x is replacedby T, and thus, every
      // occurrence of x.type.suffix in such a branch becomes T.suffix.
      // We handle this by collapsing the suffix, similarly to the case above.
      // This is only relevant when checking safety properties, and can create
      // false positives; it can be refined by supporting path-depedent types
      case gt: GroundType => s"gtype(${groundTypes(gt)})"
      case at: AppType => s"gtype(${groundTypes(at)})"
      case sv: SyntTypeVar => s"tvar(${variables(sv)})"
      case vp2: TypeVarPrefix => lookup(vp2)
      case oth => {
        throw new RuntimeException(s"BUG: unsupported variable prefix: ${oth}")
      }
    }
    case mb: Mailbox => s"mtype(${mailboxes(mb)})"
    case c if c.isChannelType => s"ctype(${channelTypes(c)})"
    case other => s"gtype(${groundTypes(other)})"
  }

  /** Get "human-readable" version of the legend, mapping user-friendly names
    * for variables and types to their alias in the mCRL2 spec. */
  def legendHR(implicit ctx: Context): Map[String, String] = {
    def stringify(t: ValueType): String = t match {
      case TypeVar(name, _) => name.toString
      case SyntTypeVar(name) => name
      case vp: TypeVarPrefix => s"${stringify(vp.prefix)}.${stringify(vp.tvar)}"
      case mb: Mailbox => Spec.MAILBOX_ALIAS // NOTE: we assume there is only one mailbox
      case oth => {
        throw new RuntimeException(s"BUG: unsupported variable prefix: ${oth}")
      }
    }

    def stringifyGT(t: ValueType): Set[String] = {
      // Turn a type name of the form "a.b.c" into Set("a.b.c", "b.c", "c")
      // This allows to refer to types by omitting their prefixes
      // NOTE: this is a kludge!
      def typeSuffixes(t: String): Set[String] = {
        val splits = List(t.split("\\."):_*)
        report.log(s"Type ${t} split into:\n${splits}")
        splits.reverse.foldLeft(List[String]()) { (acc, tp) =>
          (acc match {
            case Nil => List(tp)
            case l @ hd :: tl => s"${tp}.${hd}" +: tl
          }) ++ acc
        }
      }.toSet
      t match {
        case t: GroundType => typeSuffixes(t.orig.show)
        case t: AppType => typeSuffixes(t.orig.show)
        case oth => {
          throw new RuntimeException(s"BUG: unsupported ground type: ${oth}")
        }
      }
    }

    val variablesHR: Map[String, String] = variables.map { kv =>
      (stringify(kv._1), s"tvar(${kv._2})")
    }

    val mailboxesHR: Map[String, String] = mailboxes.map { kv =>
      (stringify(kv._1), s"mtype(${kv._2})")
    }

    report.log(s"Ground types:\n${groundTypes.store}")
    val groundTypesHR: Map[String, String] = Map(
      // FIXME: strangely, the types of 'k' and 'v' below cannot be inferred
      groundTypes.store.toSeq.map { (k: ValueType, v: String) =>
        stringifyGT(k).map((_, s"gtype(${v})"))
      }.flatten:_*
    )
    report.log(s"Human-readable legend for ground types:\n${groundTypesHR}")

    variablesHR ++ mailboxesHR ++ groundTypesHR
  }

  private val processes = FreshNames[RecVar](
    "Processes generated from recursion variables",
    "P", "")

  private lazy val preamble: String = resource("/mcrl2/effpi-preamble.mcrl2")
  private lazy val init: String = resource("/mcrl2/effpi-init.mcrl2")

  /** Return the mCRL2 specification as a string */
  def show: String = show(true)
  def show(withLegend: Boolean): String = {
    // Access body first, to trigger its autogeneration and fill the legend
    val body = process

    preamble ++ "\n\n" ++
      (if (withLegend) legend else "") ++
      body.toDef("process").render ++ "\n\n" ++
      init
  }

  /** Convert into an mCRL2 process */
  lazy val process: Proc = {
    // NOTE: this method should NOT call itself recursively: instead,
    // calling toProcess below ensures the currect population of nameSuppliers
    toProcess(this)
  }
  
  private def toProcess(spec: Spec): Proc = spec match {
    case End() => Proc()
    case InBranch(choices) => convertChoices(choices, "i")
    case OutBranch(choices) => convertChoices(choices, "o")
    case Par(s1, s2) => toProcess(s1) || toProcess(s2)
    case Or(s1, s2) => toProcess(s1).tauPrefix + toProcess(s2).tauPrefix
    case Rec(recvar, body) => {
      // NOTE: we exploit the Barendregt convention, to guarantee proc fresh
      val proc = processes(recvar)
      // Encode the recursive process definition into dSpec...
      val dSpec = toProcess(body).toDef(proc)
      // ...and return a process that calls the defs we just placed in dSpec
      Proc(List(proc)) + dSpec
    }
    case r @ RecVar(_) => Proc(List(s"${processes(r)}"))
  }

  /** Utility method to convert a series of choices into a branching process */
  private def convertChoices(cs: Map[Choice, Spec],
                             action: String): Proc = cs.map { cSpec =>
    assert((action == "i") || (action == "o"))
    val contProc = toProcess(cSpec._2)
    Proc(
      s"${action}(${lookup(cSpec._1.from)}, ${lookup(cSpec._1.to)}, ${lookup(cSpec._1.payload)})" +: contProc.current,
      contProc.defs
    )
  }.foldLeft(Proc()) { _ + _ }

  override val toString: String = s"Spec(${description})"
}

case class End()(val ccstTerm: ccst.CCST, override val description: String = "") extends Spec(ccstTerm, description)

case class Choice(from: ValueType, to: ValueType, payload: ValueType)

case class InBranch(choices: Map[Choice, Spec])(val ccstTerm: ccst.CCST, override val description: String = "") extends Spec(ccstTerm, description)
case class OutBranch(choices: Map[Choice, Spec])(val ccstTerm: ccst.CCST, override val description: String = "") extends Spec(ccstTerm, description)

case class Or(p1: Spec, p2: Spec)(val ccstTerm: ccst.CCST, override val description: String = "") extends Spec(ccstTerm, description)
case class Par(p1: Spec, p2: Spec)(val ccstTerm: ccst.CCST, override val description: String = "") extends Spec(ccstTerm, description)
case class Rec(recvar: RecVar, body: Spec)(val ccstTerm: ccst.CCST, override val description: String = "") extends Spec(ccstTerm, description)
case class RecVar(name: String)(val ccstTerm: ccst.CCST, override val description: String = "") extends Spec(ccstTerm, description)

object Spec {
  import dotty.tools.dotc.core.Contexts.Context
  import dotty.tools.dotc.core.Types

  import effpi.verifier.Verifier.canCommunicate

  /** Handle used to refer to mailboxes in verification properties. */
  val MAILBOX_ALIAS = "mb_"

  def apply(p: ccst.CCST)(implicit ctx: Context): Spec = {
    apply(p, p.inputs, p.outputs)
  }

  private def apply(p: ccst.CCST,
                    inputs: Set[ccst.ChanPayload],
                    outputs: Set[ccst.ChanPayload])
                    (implicit ctx: Context): Spec = p match {
    case ccst.End => End()(p)
    case ccst.Out(chan, payload, cont) => {
      val cont2 = apply(cont, inputs, outputs)
      val branches = Seq((Choice(chan, chan, payload), cont2)) ++ {
        // Is the output already covered by some input?
        val coverage = inputs.filter { i =>
          canCommunicate(chan, i.chan)
        }.filter { i =>
          payload == i.payload
        }
        if (!coverage.isEmpty) {
          Seq() // Nothing to add
        } else for {
          // Add an output branch for each compatible input in the type
          to <- inputs if canCommunicate(chan, to.chan)
        } yield (Choice(chan, to.chan, to.payload), cont2)
      }
      OutBranch(Map(branches:_*))(p)
    }
    case ccst.Branch(choices) => {
      val baseBranches = for {
        (to, cont) <- choices
      } yield (Choice(to.chan, to.chan, to.payload), apply(cont, inputs, outputs))
      val extraBranches = for {
        (to, cont) <- choices
        // Add an input branch for each compatible output in the type
        // NOTE: the received payload is already substituted in cont
        from <- outputs if canCommunicate(from.chan, to.chan)
      } yield (Choice(from.chan, to.chan, to.payload), apply(cont, inputs, outputs))
      InBranch(baseBranches ++ extraBranches)(p)
    }
    case ccst.Or(p1, p2) => Or(apply(p1, inputs, outputs),
                               apply(p2, inputs, outputs))(p)
    case ccst.Par(p1, p2) => Par(apply(p1, inputs, outputs),
                                 apply(p2, inputs, outputs))(p)
    case ccst.Rec(rv, body) => Rec(RecVar(rv.name)(rv), apply(body, inputs, outputs))(p)
    case ccst.RecVar(name) => RecVar(name)(p)
  }
}
